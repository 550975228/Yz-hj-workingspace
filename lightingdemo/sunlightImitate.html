<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>这玩意用来测试时间滑块控件的实现的</title>
    <style>
        * {
            box-sizing: border-box
        }

        body {
            font-family: Arial;
            padding: 10px;
            background: #f1f1f1;
        }

        .leftcolumn {
            float: left;
            width: 75%;
        }

        .rightcolum {
            float: left;
            width: 25%;
            background-color: #f1f1f1;
            padding-left: 20px;
            padding-right: 20px;
        }

        .card {
            background-color: gainsboro;
            padding: 20px;
            margin-top: 20px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
    <link rel="stylesheet" href="libs/layui/css/layui.css" media="all">

    <script id="vertexShader" type="x-shader/x-vertex">
      attribute vec4 a_Position; //顶点数据
      attribute vec4 a_Normal;   //法线数据
      attribute vec4 a_Color;
      uniform mat4 u_MvpMatrix;//模型视图投影矩阵
      uniform mat4 u_ModelMatrix;  // 模型矩阵
      uniform mat4 u_NormalMatrix;   // 模型的逆转置矩阵，用于计算变化后的法线。
      varying vec4 v_Color; //顶点颜色
      varying vec3 v_Normal;   //变化之后的顶点的法线
      varying vec3 v_Position;//世界坐标系中的顶点位置
      void main() {
        gl_Position = u_MvpMatrix * a_Position; //球的位置
        v_Position = vec3(u_ModelMatrix * a_Position); //计算顶点在世界坐标系中的位置。
        v_Normal = normalize(vec3(u_NormalMatrix * a_Normal));//计算变化之后的顶点法线
        v_Color = a_Color; //顶点颜色
      }


    </script>
    <script id="fragmentShader" type="x-shader/x-vertex">
      #ifdef GL_ES
      precision highp float;
      #endif
      uniform vec3 u_LightColor;   // 灯光颜色
      uniform vec3 u_LightPosition;  // 光源的位置
      uniform vec3 u_AmbientLight;  // 环境光颜色
      varying vec3 v_Normal;   //顶点法线
      varying vec3 v_Position;//顶点位置
      varying vec4 v_Color; //顶点颜色
      void main() {
         //再次对法线归一化，因为被插值了。
        vec3 normal = normalize(v_Normal);
         //计算光的方向并归一化
        vec3 lightDirection = normalize(u_LightPosition - v_Position);//计算
         //用点积计算光与法线夹角的cos值。
        float nDotL = max(dot(lightDirection, normal), 0.0);
         //计算漫反射光
        vec3 diffuse = u_LightColor * v_Color.rgb * nDotL;
         //计算环境光
        vec3 ambient = u_AmbientLight * v_Color.rgb;
        //最终的颜色
        gl_FragColor = vec4(diffuse + ambient, v_Color.a);
      }


    </script>
</head>
<body onload="main()">

<div class="leftcolumn">
    <div class="card">
        <h2 style="text-align: center">太阳光光照模拟</h2>
        <canvas id="canvas"></canvas>
    </div>
</div>
<div class="rightcolum">
    <div class="card">
        <h2>这里放控制栏</h2>
        <div>

            <fieldset class="layui-elem-field layui-field-title" style="margin-top: 30px;">
                <legend>时间选择：</legend>
            </fieldset>
            <div id="timeSlider" class="daytime-slider"></div>
        </div>
    </div>
</div>
<script src="libs/layui/layui.all.js" charset="UTF-8"></script>
<script src="libs/sunRealHour.js"></script>
<script src="libs/sunCaculateFunction.js"></script>
<script src="libs/webgl_utils"></script>
<script src="libs/webgl_debug.js"></script>
<script src="libs/cuon_matrix.js"></script>
<script src="libs/cuon_utils.js"></script>
<script src="sunlightImitate.js"></script>

</body>
</html>





















